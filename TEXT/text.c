#include "text.h"
#include "lcd.h"
//////////////////////////////////////////////////////////////////////////////////	 
//本程序只供学习使用，未经作者许可，不得用于其它任何用途
//ALIENTEK Warship STM32开发板
//OLED汉字显示驱动代码
//驱动方式:8080并口
//正点原子@ALIENTEK
//技术论坛:www.openedv.com
//修改日期:2019/09/09
//版本：V1.0
//版权所有，盗版必究。
//Copyright(C) 广州市星翼电子科技有限公司 2009-2019
//All rights reserved	   
////////////////////////////////////////////////////////////////////////////////// 	


//24*24的OLED汉字点阵，包括三个汉字：开、发、板。这三个汉字的点阵库，是利用PCtoLCD2002生产的，
//软件设置的取模方式同OLED实验ASCII的取模方式一样，字体采用24*24大小，一个汉字点阵占用72字节。
const u8 LCD_HZK_TBL[7][72]=
{
	
{0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x02,0x08,0x08,0x02,0x08,0x08,0x04,0x08,0x08,0x08,0x08,0x08,0x10,0x08,0x08,0xE0,
0x0F,0xFF,0x80,0x08,0x08,0x00,0x08,0x08,0x00,0x08,0x08,0x00,0x08,0x08,0x00,0x08,0x08,0x00,0x08,0x08,0x00,0x0F,0xFF,0xFE,
0x0F,0xFF,0xFE,0x08,0x08,0x00,0x08,0x08,0x00,0x10,0x08,0x00,0x10,0x10,0x00,0x00,0x30,0x00,0x00,0x00,0x00,0x00,0x00,0x00},/*"开",0*/
	
{0x00,0x00,0x00,0x00,0x00,0x02,0x00,0x00,0x04,0x01,0x80,0x08,0x0F,0x00,0x10,0x1C,0x80,0x60,0x00,0x81,0xC2,0x00,0x87,0x02,
0x00,0xFC,0x02,0x1F,0xF0,0x04,0x3C,0x9C,0x08,0x20,0x92,0x08,0x00,0x91,0x90,0x00,0x90,0x70,0x00,0x90,0x60,0x20,0x91,0x90,
0x10,0x93,0x18,0x1C,0x9C,0x08,0x0C,0x98,0x0C,0x00,0x80,0x04,0x01,0x00,0x06,0x01,0x00,0x04,0x00,0x00,0x04,0x00,0x00,0x00},/*"发",1*/
	
{0x00,0x00,0x00,0x00,0x00,0xC0,0x01,0x01,0x00,0x01,0x0E,0x00,0x01,0xF8,0x00,0x3F,0xFF,0xFE,0x21,0x20,0x00,0x01,0x10,0x02,
0x02,0x0C,0x0E,0x00,0x00,0x12,0x00,0x07,0xE4,0x0F,0xFE,0x04,0x08,0x40,0x08,0x08,0x78,0x10,0x08,0x47,0x30,0x08,0x41,0xE0,
0x10,0x41,0xE0,0x10,0x47,0x30,0x30,0x7C,0x18,0x30,0xE0,0x0C,0x10,0x00,0x0C,0x00,0x00,0x04,0x00,0x00,0x00,0x00,0x00,0x00},/*"板",2*/
	
{0x00,0x00,0x00,0x60,0x00,0x44,0x60,0x00,0xE6,0x60,0x00,0xC6,0x6F,0xF9,0x86,0x6F,0xF9,0x84,0x6D,0x5B,0x8C,0x6D,0x5F,0xCC,
0x6D,0x5F,0xCC,0x6D,0x5B,0x68,0x7D,0x5B,0x38,0x7D,0x5B,0x18,0x6D,0x5B,0x38,0x6D,0x5B,0x78,0x6D,0x5B,0x6C,0x6D,0x5B,0xCC,
0x6D,0x5B,0x8E,0x6F,0xFB,0x06,0x6F,0xFE,0x06,0x60,0x00,0x06,0x60,0x00,0x06,0x60,0x00,0x04,0x00,0x00,0x00,0x00,0x00,0x00},/*"夏"，3*/
	
{0x00,0x00,0x00,0x00,0x00,0x04,0x20,0x20,0x0C,0x30,0x20,0x18,0x3C,0x3F,0xF0,0x1C,0x3F,0xF0,0x00,0x00,0x18,0x00,0x10,0x08,
	0x04,0x10,0x2C,0x04,0x10,0xF4,0x04,0x17,0xE4,0x7F,0xFF,0x84,0x7F,0xF8,0x04,0x04,0x10,0x04,0x04,0x10,0x04,0x04,0x10,0x04,
	0x7F,0xFF,0xF4,0x7F,0xFF,0xF4,0x44,0x10,0x04,0x04,0x10,0x04,0x04,0x10,0x0C,0x04,0x10,0x0C,0x00,0x00,0x08,0x00,0x00,0x00},/*“进”，4*/
	
{0x00,0x00,0x78,0x00,0x00,0xC8,0x00,0x01,0x08,0x08,0x03,0x08,0x14,0x02,0x10,0x14,0x02,0xD0,0x14,0x03,0xE0,0x14,0x00,0x40,
	0x0C,0x00,0x80,0x0F,0x01,0x80,0x07,0xC1,0x00,0x05,0xE2,0x00,0x0C,0x7C,0x00,0x1C,0x3C,0x00,0x18,0x3F,0x00,0x00,0xE7,0xC0,
	0x03,0x81,0xE0,0x06,0x00,0x70,0x0C,0x00,0x18,0x08,0x00,0x04,0x0A,0x00,0x04,0x0C,0x00,0x04,0x00,0x00,0x08,0x00,0x00,0x00},/*"艺术X",5*/
	
{0x00,0x00,0x00,0x00,0x00,0x1C,0x00,0x00,0x14,0x00,0x00,0x14,0x00,0x00,0x1C,0x00,0x00,0x1C,0x00,0x00,0x34,0x00,0x00,0x36,
	0x00,0x00,0x37,0x00,0x00,0x15,0x00,0x00,0x1D,0x00,0x00,0x3A,0x01,0xC0,0xFA,0x03,0xE1,0xEC,0x02,0x27,0x84,0x04,0x6F,0x04,
	0x08,0x7E,0x0C,0x13,0xF0,0x0C,0x17,0xC0,0x14,0x3F,0x00,0x18,0x7C,0x00,0x00,0x70,0x00,0x00,0xC0,0x00,0x00,0xC0,0x00,0x00},/*"艺术J",6*/
};	
	 
//在指定位置，显示一个24*24大小的汉字
//x,y :汉字的坐标
//index:汉字编号（在字库数组里面的编号） 
void LCD_Show_Font(u16 x,u16 y,u8 index)
{
	u8 temp,t,t1;
	u16 y0=y;
	u8 *dzk;   
	u8 csize=72;					//一个24*24的汉字72字节
	dzk=(u8*)LCD_HZK_TBL[index];	//得到汉字编号对应的点阵库 
	for(t=0;t<csize;t++)
	{   												   
		temp=dzk[t];				//得到点阵数据                          
		for(t1=0;t1<8;t1++)			//按照从高位到低位的顺序画点
		{
			if(temp&0x80)LCD_Fast_DrawPoint(x,y,POINT_COLOR);
			else LCD_Fast_DrawPoint(x,y,BACK_COLOR); 
			temp<<=1;
			y++;
			if((y-y0)==24)			//对y坐标的处理，当y坐标距起始坐标差24个像素点，x坐标加1
			{
				y=y0;
				x++;
				break;
			}
		}  	 
	}  
}
















